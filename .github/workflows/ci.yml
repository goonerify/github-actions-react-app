name: CI
on:
  pull_request:
    branches: [develop]
  push:
    branches: [develop]

jobs:
  build:
    env:
      GNU_PG_PASSPHRASE: ${{ secrets.GNU_PG_PASSPHRASE }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache node_modules
        uses: actions/cache@v1
        with:
          path: ~/.npm
          # The workflow will search for a cache that is saved under myKey in our caches
          # If found, the cache will be used, otherwise a new key will be created to point
          # to the cached files
          # key: myKey
          # Use the hash file function to hash all package-lock.json files in the application
          # - if we have more than one. Changes to a package-lock.json file indicate that some
          # dependencies in the application have changed and the cached dependencies should be
          # updated
          # key: node-${{ hashFiles('**/package-lock.json') }}
          # Generate a new cache when the operating system has changed since cached files are
          # different for each operating system
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          # Github can use restore keys to find caches if it doesn't find cache hits using the main key
          # This will happen in any new branch. Github can use the restore-keys to find caches in other
          # branches that begins with the value of the restore key. Once the entire workflow is completed,
          # the new cache will be saved for the current branch. There can be multiple restore keys.
          # https://docs.github.com/en/actions/guides/caching-dependencies-to-speed-up-workflows#matching-a-cache-key
          restore-keys: |
            ${{ runner.os }}-node-
      - name: list files
        run: |
          ls -la
      - name: Decrypt Secret File
        run: gpg --quiet --batch --yes
          --decrypt --passphrase="$GNU_PG_PASSPHRASE" --output .env .env.gpg
      - name: list files after decrypt
        run: |
          pwd
          ls -la
      - id: dotenv
        name: Dotenv Action
        uses: falti/dotenv-action@v0.2.6
      - name: Use NodeJS
        uses: actions/setup-node@v2.3.0
        with:
          node-version: 14.x
      - run: npm ci
      - run: npm run format:check
      - run: npm test -- --coverage
        env:
          CI: true
      # Run this job after testing to ensure the coverage file has been created
      - name: Upload Test Coverage
        uses: actions/upload-artifact@v2.2.4
        with:
          # Name of the file that will be available for download
          name: code-coverage
          path: coverage
      - name: Build Project
        if: github.event_name == 'push'
        run: npm run build
      # Run this job after "Build Project" to ensure the build folder has been created
      # - name: Upload Build Folder
      #   if: github.event_name == 'push'
      #   uses: actions/upload-artifact@v2.2.4
      #   with:
      #     # Name of the file that will be available for download
      #     name: build
      #     path: build
      # Download an artifact to your workspace
      # - uses: actions/download-artifact@v2.0.10
      #   with:
      #     name: my-artifact
      # - name: Display structure of downloaded files
      #   run: ls -R
      - name: Deploy to Staging
        if: github.event_name == 'push'
        run: |
          echo $SURGE_DOMAIN
          echo $SURGE_LOGIN
          echo $SURGE_TOKEN
          npx surge --project ./build --domain $SURGE_DOMAIN
        env:
          SURGE_DOMAIN: ${{ steps.dotenv.outputs.SURGE_DOMAIN }}
          SURGE_LOGIN: ${{ steps.dotenv.outputs.SURGE_LOGIN }}
          SURGE_TOKEN: ${{ steps.dotenv.outputs.SURGE_TOKEN }}
